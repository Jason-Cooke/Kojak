{"name":"Kojak","tagline":"Kojak - A Simple JavaScript Performance Profiler","body":"##Kojak: A simple JavaScript profiler [![Build Status](https://api.travis-ci.org/theironcook/Kojak.png)](http://travis-ci.org/theironcook/Kojak)\r\n\r\n####What is Kojak?\r\nKojak is a simple utility that can help you figure out which of your JavaScript functions are running too slow. It tracks which of your\r\nfunctions are called, how often they are called, how much time they are taking, how the functions were called.  It can also track your ajax calls\r\nand help figure out how fast they are. (<a href=\"http://en.wikipedia.org/wiki/Kojak\">Kojak</a> was a tv show detective)\r\n\r\n####Why Kojak?\r\nI've found that Chrome's developer tools or Firebug have too much noise to make sense of my own code.  I needed a tool\r\nthat would remove all of the noise of external or core JavaScript code.  Kojak helps you focus on the performance of\r\nyour own code and eliminate the clutter.  It's helped me / my project to significantly speed up our JavaScript code. Hopefully\r\nit can help you and your projects.\r\n\r\n####Dependencies\r\nThe core of Kojak has no external dependencies.  I've worked hard to avoid using any other libraries so that the tool is\r\nlight weight and easy to use. You need a modern browser such as Chrome, Firefox or IE 8.0+.\r\nIf you want to profile ajax network requests you will need to include jQuery.\r\n\r\n<br>\r\n####How to use it (the short version)\r\nTo use Kojak copy/download the Kojak.min.js file.  Include it in the browser code you want to profile.  You can include it with\r\na normal script tag or you can also just copy and paste the Kojak.min.js file directly into a running browser console.\r\nYou can actually profile code in any web site as long as you know what the code root namespaces are (discussed later).\r\n\r\nKojak expects that your code is accessible via the window object.  A typical application might be assembled like this:\r\n\r\n````\r\nvar myProject = {models: {}, views: {}, controllers: {}, utils: {}};\r\nmyProject.models.ModelA = function(){};\r\nmyProject.views.ViewA = function(){};\r\nmyProject.utils.sharedUsefulFunction = function(){};\r\n````\r\n\r\nThe classes/functions live somewhere under the window object.  In the example above, the code lives under window.myProject.\r\nKojak will probably be extended in the future to support code not directly accessible under window.\r\nIt's not that hard to enable it for requireJS style modules with a quick shim to expose the modules to Kojak.\r\n\r\nTo quickly get started with Kojak you could run the following commands in the browser's console:\r\n````\r\n  // replace with your own root package names\r\n  kConfig.setIncludedPakages(['myProject']);\r\n\r\n  // this will root recursively through all your code, starting with the included packages and wrap every\r\n  // single function it finds to keep track of all of the function's runtime information\r\n  kInst.instrument();\r\n\r\n  // See which functions have been instrumented in your application\r\n  kRep.instrumentedCode();\r\n\r\n  // Now you should do something with your application that does not include a full page refresh\r\n\r\n  // Now see which are your slowest functions.  This only includes the instrumented functions.\r\n  kRep.funcPerf();\r\n````\r\n\r\nKojak has a lot of other features that I'll explain later, but first I need to explain how Kojak makes sense of JavaScript.\r\n\r\n<br>\r\n####Supported code formats\r\n\r\n<i>If this section is confusing I would recommend reading <a href=\"http://www.amazon.com/Secrets-JavaScript-Ninja-John-Resig/dp/193398869X/ref=sr_1_1?s=books&ie=UTF8&qid=1382038307&sr=1-1&keywords=secrets+of+the+javascript+ninja\">chapters 1-6</a>.</i>\r\n\r\nKojak recognizes 3 types of data structures in your code\r\n* `Pakage`\r\n* `Clazz`\r\n* `function`\r\n\r\nA `Pakage` is anything that might contain your code. A `Pakage` might be a Plain Old JavaScript Object (POJO) that looks like {}.\r\nA `Pakage` might also be a `Clazz` that contains other `Clazzes` or `Pakages`.\r\nIn the example below, myProject, myProject.models, myProject.models.ModelA and myProject.models.ModelA.NestedModelB are all considered Pakages:\r\n````\r\nvar myProject = {models: {}, views: {}};\r\nmyProject.models.ModelA = function(){};\r\nmyProject.models.ModelA.NestedModelB = function(){};\r\n````\r\n\r\nA `Clazz` is a function that is expected to be used with the `new` operator.  `Clazzes` are expected to be named starting\r\nwith an upper case character. In the previous example ModelA and NestedModelB are both `Classes`.\r\n\r\nA `function` is just a normal JavaScript function that Kojak does not think is a `Clazz`.  Kojak looks for functions\r\nin `Pakage`, `Clazz` or under the `Clazz`.`prototype`.\r\n\r\nFor example, Kojak will profile the functions `packageFunction`, `classLevelFunction` and the `prototypeLevelFunction`:\r\n````\r\nmyProject.packageFunction = function(){};\r\nmyProject.models.ModelA = function(){};\r\nmyProject.models.ModelA.classLevelFunction(){};\r\nmyProject.models.ModelA.prototype.prototypeLevelFunction(){};\r\n````\r\n\r\nIt's important for Kojak to understand when a function will be invoked with the `new` operator and to avoid wrapping\r\nthose type of functions directly.  If Kojak finds <b>any</b> reference to a function that starts with an upper case it will\r\nassume the function is a `Clazz`.\r\n\r\nThe example below shows this:\r\n````\r\nmyProject.models.ModelA = function(){};\r\nmyProject.someCodePackage = {\r\n  refToModelA: myProject.models.ModelA\r\n};\r\n````\r\n\r\nIn the example above, ModelA is also referenced with the name refToModelA.  Kojak understands that ModelA and refToModelA both\r\nreference the same function and that one of those references looks like a Clazz.  In that situation, Kojak will assume\r\nall references should behave as a Clazz.  If Kojak accidentally wraps a function and the function is invoked with the\r\n`new` operator Kojak will throw a runtime exception with a message explaining which function was instrumented incorrectly\r\nas a function instead of a Clazz.\r\n\r\n<br>\r\n####How to use it (the long version)\r\nKojak needs to be told what code it is supposed to profile.  You tell Kojak via the command:\r\n````kConfig.setIncludedPakages(['packageA', 'packageB'])````\r\n\r\nKojak will use these package names as entry points to find all of the code that you probably care about.\r\n\r\nYou can also tell Kojak to exclude functions or packages with this command:\r\n```` kConfig.setExcludedPaths(['packageA.SomeClass.funcA', 'packageA.SomeClass.funcB']); ````\r\n\r\nKojak will then ignore funcA and funcB.  The excluded paths can be fully qualified function paths or namespaces etc.\r\n\r\nThere are several other options in `kConfig` that are discussed in a later section.  All options set with `kConfig` are persisted\r\nautomatically in the browser's local storage.  So, the next time you refresh a page etc. your Kojak options are saved.\r\n\r\n<br>\r\nAfter you've told Kojak what it should are about and what to exclude you need to run this command:\r\n```` kInst.instrument(); ````\r\n\r\nThe `instrument` function will locate every single `Pakage`, `Clazz` and `function` that can be found recursively through\r\nwhat you specified in the kConfig. Kojak will inject a `_kPath` string in each `Pakage` and `Clazz` that is the fully qualified\r\npath to the `Package` or `Clazz` so that they can be self aware of where they live.\r\n\r\nThe `instrument` function replace each `function` it finds with a wrapper function.  The wrapper function helps Kojak to\r\ntrack everything that happens with that function. The new wrapper function contains a `_kFProfile` property.  The `_kProfile`\r\nproperty keeps track of all of the information of what is a happening with the function.\r\n\r\nYou can check which functions have been instrumented with this command:\r\n```` kRep.instrumentedCode(); ````\r\n\r\nIf you want more details you can run this command:\r\n```` kRep.instrumentedCode({verbose: true}); ```\r\n\r\n<br>\r\nAfter you have told Kojak to instrument your code you can now invoke your code.  Typically you will click on something etc.\r\nAfter some of your code has ran you want to see why it was so slow.  To determine which functions are too slow run the command:\r\n```` kRep.funcPerf(); ````\r\n\r\nBy default, this function will return the 20 slowest functions that have been profiled. For example:\r\n\r\n````\r\nTop 20 functions displayed sorted by IsolatedTime'\r\n--KPath--                                                                    --IsolatedTime--  --WholeTime--  --CallCount--\r\nMyProject.views.schedule.ResourceListView.prototype._positionAppointments     392               426            77\r\nMyProject.views.schedule.ResourceListView.prototype._createGridLines          351               367            35\r\nMyProject.domain.BaseModel.prototype.get                                       99                230            14,679\r\nMyProject.domain.BaseModel.prototype._getResolvedAttributeTypes                98                98             14,926\r\nMyProject.views.schedule.ScheduleView.prototype._sizeWeekViewResourceColumns   78                78             28\r\n...\r\n````\r\n\r\nThe funcPerf() will report 3 different fields for each function\r\n * IsolatedTime\r\n * WholeTime\r\n * CallCount\r\n\r\nIsolatedTime is how much cumulative time was spent inside the function itself.  Whole time includes other functions.\r\n\r\nFor example, funcA takes 1 second and funcB takes 2 seconds.  If we modify funcA to internally call funcB the results would\r\nlook like this:\r\n````\r\n--KPath--  --IsolatedTime--  --WholeTime--  --CallCount--\r\nfuncA         1,000              3,000         1\r\nfuncB         2,000              2,000         1\r\n````\r\n\r\nfuncA's IsolatedTime would be 1,000 milliseconds but it's whole time would be 3,000 milliseconds.  Most of the time, you\r\n will probably care more about IsolatedTime than WholeTime.\r\n\r\nThe funcPerf() function can take the following options:\r\n* sortBy - kRep.funcPerf({sortBy: 'WholeTime'});\r\n* max - kRep.funcPerf({max: 30}); // I want 30 results instead of the default of 20\r\n* filter - kRep.funcPerf({filter: ['BaseModel', 'BaseView']}); // I only want results that contain 'BaseModel' or 'BaseView' in their path\r\n\r\n<br>\r\nAfter seeing what your slowest functions are you might want to know how they are being invoked.  This is particularly\r\nimportant for when a function's CallCount is unacceptably high.\r\n\r\nTo figure out who is calling a function run this command:\r\n````\r\nkRep.callPaths(MyProject.someFunc);\r\n\r\n// Example results\r\n--Call Count--  --Invocation Path--\r\n1,380           MyProject.foo > MyProject.models.ModelA.prototype.bar > MyProject.something\r\n...\r\n````\r\n\r\nThe invocation paths will only include functions that Kojak has instrumented.  These call paths can help you track down\r\nwhy a function is called too much.\r\n\r\n<br>\r\n####Tracking performance in between actions\r\nSometimes it's helpful to take performance checkpoints between actions and not include any previous results.  Sometimes it\r\ncan take a long time to set up a test and you don't want to have to repeat steps.  You can only run kInst.instrument() one time.\r\n\r\nTo do this use this command:\r\n```` kInst.takeCheckpoint(); ````\r\n\r\nThen perform your action.\r\n\r\nThen run this command:\r\n```` kRep.funcPerfAfterCheckpoint(); ````\r\n\r\nThe funcPerfAfterCheckpoint() is identical to funcPerf() and can accept the same parameters.  The difference is that\r\n  the function results (IsolatedTime etc.) are only since the last time takeCheckpoint() was called.\r\n\r\nSometimes it's particularly interesting to watch the CallCount's for functions when running the identical actions.  Most of\r\nthe time the CallCount numbers should be identical.  If they are not, you probably have some type of memory leak.\r\n\r\n\r\n<br>\r\n####Tracking Network Requests\r\nKojak can also track all of your network ajax requests.  To use the NetWatcher you must use jQuery.  To enable run this command:\r\n```` kConfig.setEnableNetWatcher(true); ````\r\n\r\nThe Kojak NetWatcher will then watch any ajax requests made.  To see a consolidated view the results use this command:\r\n````\r\nkRep.netCalls();\r\n// Example output\r\n--urlBase--            --urlParameters--    --When Called--  --Call Time--  --Size (bytes)--  --Obj Count--\r\n/kpi/SOME_KPI [GET]      <none>                01:04:22 PM      3,442          386               8\r\n...\r\n````\r\n\r\nThe results are consolidated by the urlBase.  The results are sorted by the Call Time.\r\n\r\nThis does not track network requests made in a Web Worker right now.\r\n\r\n\r\n<br>\r\n####Full API and Options\r\n\r\nkConfig (configuration)<hr>\r\n````\r\n// Sets whether the net watcher is enabled.  If you set it to true you need to have jQuery loaded.\r\n// If net watcher is enabled it starts running as soon as the Kojak libary is loaded.\r\nkConfig.setEnableNetWatcher(enabled);\r\n\r\n// Sets if/how Kojak is supposed to automatically start code instumentation\r\n// Possible vals include:\r\n//   Kojak.Config.AUTO_START_NONE\r\n//   Kojak.Config.AUTO_START_IMMEDIATE - will not work for more complex code\r\n//   Kojak.Config.AUTO_ON_JQUERY_LOAD - obviously jQuery needs to be loaded\r\n//   Kojak.Config.AUTO_START_DELAYED - use in conjunction with kConfig.setAutoStartDelay(millis);\r\nkConfig.setAutoStartInstrumentation(val);\r\n\r\n// If using Kojak.Config.AUTO_START_DELAYED, this is how many milliseconds to wait before calling kInst.instrument();\r\nkConfig.setAutoStartDelay(millis);\r\n\r\n// If you want to log when EVERY single function that has been profiled is invoked call this with true\r\n// Be careful with this - you will see many many messages\r\nkConfig.setRealTimeFunctionLogging(val);\r\n\r\n// Overwrites previously included pakages\r\n// pakages is an array of strings\r\n// Kojak will use these pakages as entry points to recursively find all code to instrument\r\nkConfig.setIncludedPakages(pakages);\r\n\r\n// Adds pakage to the list of included pakages\r\n// pakage is a string\r\nkConfig.addIncludedPakage(pakage);\r\n\r\n// Removes pakage from the list of included pakages\r\n// pakage is a string\r\nkConfig.removeIncludedPakage(pakage);\r\n\r\n// See the list of included pakages\r\nkConfig.getIncludedPakages();\r\n\r\n// Overwrites the previously excluded paths\r\n// paths is an array of strings\r\n// Kojak will skip any Pakage, Clazz or function that partially matches any of the paths\r\nkConfig.setExcludedPaths(paths);\r\n\r\n// Adds path to the list of excluded paths\r\n// path is a string\r\nkConfig.addIncludedPath(path);\r\n\r\n// Removes path from the list of excluded paths\r\n// path is a string\r\nkConfig.removeExcludedPath(path);\r\n\r\n// See the list of excluded paths\r\nkConfig.getExcludedPaths();\r\n````\r\n\r\nkInst (instrumentation)<hr>\r\n````\r\n// Call this once to instrument your code base.  Cannot be called more than once\r\n// Every specified (in kConfig) function will be replaced with a wrapper function.\r\nkInst.instrument();\r\n\r\n// Takes a checkpoint of the function execution metrics\r\n// After calling this run your code and the use kRep.funcPerfAfterCheckpoint()\r\nkInst.takeCheckpoint();\r\n````\r\n\r\nkRep (reporting)<hr>\r\n````\r\n// Check what code Kojak has instrumented\r\n// options is a JavaScript object that can have the following values\r\n//   verbose: true - will report not only Pakages and Clazzes but also function names and call counts\r\n//   filter: ['xxx', 'xxx'] - can be a string or an array of strings.  Only code matching a filter will be reported\r\nkRep.instrumentedCode(options);\r\n\r\n// Check the instrumented function performance\r\n// options is a JavaScript object that can have the following values\r\n//   sortBy - possible values include 'IsolatedTime', 'WholeTime', 'CallCount'\r\n//   max - how many rows do you want to return\r\n//   filter: ['xxx', 'xxx'] - can be a string or an array of strings.  Only code matching a filter will be reported\r\nkRep.funcPerf(options);\r\n\r\n// Identical to funcPerf but the function performance metrics are only after the last time kInst.takeCheckpoint() was called\r\nkRep.funcPerfAfterCheckpoint(options);\r\n\r\n// Only call this if you have enabled the net watcher\r\n// Returns all of the network calls sorted by call time.\r\nkRep.netCalls();\r\n````\r\n\r\n\r\n<br>\r\n####How to compile it locally\r\nNormally you won't need to do this unless you are forking the code.  If you do want to fork the code.\r\n* Install NodeJS\r\n* Install GIT\r\n* Fork the code (git clone https://github.com/theironcook/Kojak/)\r\n* Navigate to the directory you forked the code and type: npm install\r\n\r\nThis will install grunt, phantom, jasmine, uglify etc. in the local node_modules directory.\r\n\r\nTo build a prod version type: grunt buildProd\r\nTo build a dev version type: grunt buildDev\r\nYou can also type: grunt watch\r\nThis will run grunt buildDev whenever a source file or a unit test changes.\r\n\r\n\r\n<br>\r\n####Change log\r\n* Changes won't be tracked tracked until version 0.2.0\r\n\r\n\r\n<br>\r\n####Legal Info (MIT License)\r\nCopyright (c) 2013 Bart Wood\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}